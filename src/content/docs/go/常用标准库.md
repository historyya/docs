---
title: 常用标准库
description: 常用标准库
sidebar:
  order: 30
---

## 文件处理

### 打开与读取文件

```go
package t

import (
	"log"
	"os"
)

func main() {
	// 打开文件
	os.Open("readme.md")

	// 创建文件
	os.Create("temp.txt")

	// 打开或创建文件
	f, err := os.OpenFile("notes.txt", os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		log.Fatal(err)
	}

	// 读取文件
	data, err := os.ReadFile("testdata/hello")
	if err != nil {
		log.Fatal(err)
	}
	os.Stdout.Write(data)

	// 写入文件
	err = os.WriteFile("testdata/hello", []byte("Hello, Gophers!"), 0666)
	if err != nil {
		log.Fatal(err)
	}

	// 关闭文件
	if err := f.Close(); err != nil {
		log.Fatal(err)
	}
}
```

### 复制文件

```go
package t

import (
	"io"
	"log"
	"os"
	"strings"
)

func main() {
	// 适用于小文件，占用内存较高
	data, err := os.ReadFile("note.txt")
	if err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile("readme.txt", []byte(data), 0666)
	if err != nil {
		log.Fatal(err)
	}

	// 高效，适用于任何大小的文件，占用内存较低
	r := strings.NewReader("some io.Reader stream to be read\n")
	if _, err := io.Copy(os.Stdout, r); err != nil {
		log.Fatal(err)
	}
}
```

### 重命名文件

```go
package t

import (
	"log"
	"os"
)

func main() {
	err := os.Rename("old.txt", "new.txt")
	if err != nil {
		log.Fatal(err)
	}
}
```

### 删除文件或目录

```go
package t

import (
	"log"
	"os"
)

func main() {
	// 提供路径，删除路径下的所有文件
	err := os.RemoveAll("logs")
	if err != nil {
		log.Fatal(err)
	}
}
```

## 目录处理

### 读取目录

```go
package main

import (
	"fmt"
	"log"
	"os"
)

func main() {
	files, err := os.ReadDir(".")
	if err != nil {
		log.Fatal(err)
	}

	for _, file := range files {
		fmt.Println(file.Name())
	}
}
```

### 创建目录

```go
package main

import (
	"log"
	"os"
)

func main() {
	err := os.Mkdir("testdir", 0750)
	if err != nil && !os.IsExist(err) {
		log.Fatal(err)
	}
	err = os.WriteFile("testdir/testfile.txt", []byte("Hello, Gophers!"), 0660)
	if err != nil {
		log.Fatal(err)
	}
}
```

#### 创建多级目录

```go
package main

import (
	"log"
	"os"
)

func main() {
	err := os.MkdirAll("test/subdir", 0750)
	if err != nil {
		log.Fatal(err)
	}
	err = os.WriteFile("test/subdir/testfile.txt", []byte("Hello, Gophers!"), 0660)
	if err != nil {
		log.Fatal(err)
	}
}
```

## HTTP

```go
package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

type User struct {
	ID        int       `json:"id"`
	Name      string    `json:"name"`
	Email     string    `json:"email"`
	Active    bool      `json:"active"`
	CreatedAt time.Time `json:"created_at"`
}

type UserStore struct {
	users  map[int]User
	mutex  sync.RWMutex
	nextID int
}

func NewUserStore() *UserStore {
	return &UserStore{
		users:  make(map[int]User),
		nextID: 1,
	}
}

func (s *UserStore) AddUser(name, email string) (User, error) {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	user := User{
		ID:        s.nextID,
		Name:      name,
		Email:     email,
		Active:    true,
		CreatedAt: time.Now(),
	}

	s.users[s.nextID] = user
	s.nextID++
	return user, nil
}

func (s *UserStore) GetUser(id int) (User, error) {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	user, ok := s.users[id]
	if !ok {
		return User{}, errors.New("user not found")
	}
	return user, nil
}

func (s *UserStore) GetList() ([]User, error) {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	users := make([]User, 0, len(s.users))
	for _, user := range s.users {
		users = append(users, user)
	}
	return users, nil
}

// Handler
type UserHandler struct {
	store *UserStore
}

func NewUserHandler(store *UserStore) *UserHandler {
	return &UserHandler{
		store: store,
	}
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	defer r.Body.Close()

	type request struct {
		Name  string `json:"name"`
		Email string `json:"email"`
	}

	var req request
	if err := json.Unmarshal(body, &req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	req.Name = strings.TrimSpace(req.Name)
	req.Email = strings.TrimSpace(req.Email)
	if req.Name == "" || req.Email == "" {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	user, err := h.store.AddUser(req.Name, req.Email)
	if err != nil {
		http.Error(w, "Failed to create user", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(user)
	return
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// /users/1
	path := strings.TrimPrefix(r.URL.Path, "/users/")
	id, err := strconv.Atoi(path)
	if err != nil {
		http.Error(w, "Invalid user id", http.StatusBadRequest)
		return
	}

	user, err := h.store.GetUser(id)
	if err != nil {
		http.Error(w, "User not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(user)
	return
}

// Config
type Config struct {
	Port     int    `json:"port"`
	logLevel string `json:"log_level"`
}

func LoadConfig(filename string) (*Config, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("打开Config文件出错: %v", err)
	}
	defer file.Close()

	bytes, err := io.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("读取Config文件出错: %v", err)
	}

	var config Config
	err = json.Unmarshal(bytes, &config)
	if err != nil {
		return nil, fmt.Errorf("解析Config文件出错: %v", err)
	}

	return &config, nil
}

func WriteConfig(filename string, config *Config) error {
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("创建Config文件出错: %v", err)
	}
	defer file.Close()

	bytes, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return fmt.Errorf("序列化Config文件出错: %v", err)
	}

	_, err = file.Write(bytes)
	if err != nil {
		return fmt.Errorf("写入Config文件出错: %v", err)
	}
	return nil
}

func main() {
	var configFile string
	var port int
	flag.StringVar(&configFile, "config", "config.json", "Config file path")
	flag.IntVar(&port, "port", 8080, "Server port")
	flag.Parse()

	config, err := LoadConfig(configFile)
	if err != nil {
		panic(err)
	}

	log.Println("Config:", config)

	userHandler := NewUserHandler(NewUserStore())
	http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodPost:
			userHandler.CreateUser(w, r)
			return
		case http.MethodGet:
			userHandler.GetUser(w, r)
			return
		default:
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}
	})

	addr := fmt.Sprintf(":%d", config.Port)
	log.Fatal(http.ListenAndServe(addr, nil))
}
```

### http.FileServer

```go
package main

import "net/http"

func main() {
	serve := http.FileServer(http.Dir("."))
	http.ListenAndServe(":8080", serve)
}
```

## 压缩

```go
package main

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"strings"
)

func main() {
	originData := "这是一段需要压缩的文本数据，" + "重复内容" + strings.Repeat("重复内容", 100) + "，结束。"

	var compressData bytes.Buffer
	writer := gzip.NewWriter(&compressData)
	_, err := writer.Write([]byte(originData))
	if err != nil {
		panic(err)
	}
	writer.Close()

	fmt.Printf("原始数据大小：%d，压缩数据大小：%d\n", len(originData), compressData.Len())
	fmt.Printf("压缩率：%.2f%%\n", float64(compressData.Len())/float64(len(originData))*100)

	// 解压
	reader, err := gzip.NewReader(&compressData)
	if err != nil {
		panic(err)
	}
	defer reader.Close()
	readAll, err := io.ReadAll(reader)
	if err != nil {
		panic(err)
	}
	fmt.Println(string(readAll))
}
```

## bufio

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

func main() {
	file, err := os.Create("file.txt")
	if err != nil {
		panic(err)
	}

	writer := bufio.NewWriter(file)
	for i := 0; i < 10; i++ {
		writer.WriteString(fmt.Sprintf("This is line %d\n", i+1))
	}
	writer.Flush()
	fmt.Println("Done")
	defer file.Close()

	f2, err := os.Open("file.txt")
	if err != nil {
		panic(err)
	}
	defer f2.Close()

	reader := bufio.NewReader(f2)
	for {
		line, err := reader.ReadString('\n')
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(err)
		}
		fmt.Println(line)
	}
}
```

## 字符串处理

```go
package main

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"unicode/utf8"
)

// 验证邮箱
func validateEmail(email string) bool {
	pattern := `^[0-9a-z][_.0-9a-z-]{0,31}@([0-9a-z][0-9a-z-]{0,30}[0-9a-z]\.){1,4}[a-z]{2,4}$`
	return regexp.MustCompile(pattern).MatchString(email)
}

// 验证手机号
func validateMobile(mobile string) bool {
	pattern := `^1[3-9]\d{9}$`
	return regexp.MustCompile(pattern).MatchString(mobile)
}

// 处理用户输入
// input: zhangsan:18:zhangsan@qq.com
func processUserInput(input string) map[string]interface{} {
	result := make(map[string]interface{})

	cleanedInput := strings.TrimSpace(input)
	cleanedInput = strings.ToLower(cleanedInput)

	split := strings.Split(cleanedInput, ":")
	if len(split) < 2 {
		result["error"] = "输入格式错误"
		return result
	}
	result["name"] = split[0]
	age, err := strconv.Atoi(split[1])
	if err != nil {
		result["age"] = "无效年龄"
	} else {
		result["age"] = age
	}

	email := split[2]
	if !validateEmail(email) {
		result["email"] = "无效邮箱"
	} else {
		result["email"] = email
	}

	result["origin_len"] = len(input)
	result["cleaned_len"] = len(cleanedInput)
	result["rune_count"] = utf8.RuneCountInString(input)

	return result
}

func main() {
	userInputs := []string{
		"zhangsan:18:zhangsan@qq.com",
		"lisi:abc:lisiqq.com",
		"王五:19:wangwu@qq.com",
	}

	for _, input := range userInputs {
		result := processUserInput(input)
		for k, v := range result {
			if k == "error" {
				fmt.Println("Invalid Input:", v)
			} else {
				fmt.Printf("%s: %v\n", k, v)
			}
		}
	}
	fmt.Println()

	phones := []string{
		"13800000001",
		"12345678901",
	}
	for _, phone := range phones {
		if validateMobile(phone) {
			fmt.Println("Valid Mobile:", phone)
		} else {
			fmt.Println("Invalid Mobile:", phone)
		}
	}

	// 字符串构造器
	var builder strings.Builder
	builder.WriteString("Hello, ")
	country := []string{"China", "USA", "Japan"}
	for _, v := range country {
		builder.WriteString(v)
		builder.WriteString("\n")
	}
	fmt.Println(builder.String())

	// 字符串的替换和重复
	str := "重要通知：{message} | 重复显示：{repeat}"
	replacedStr := strings.Replace(str, "{message}", "系统维护通知", 1)
	repeatedStr := strings.Repeat("注意！", 3)
	finalStr := strings.Replace(replacedStr, "{repeat}", repeatedStr, 1)
	fmt.Println(finalStr)  // 重要通知：系统维护通知 | 重复显示：注意！注意！注意！

	// 字符串的前缀和后缀
	url := "https://example.com/api/v1/users"
	if strings.HasPrefix(url, "https://") {
		fmt.Println("Valid URL")
	}
}
```

## Time

```go
package main

import (
	"fmt"
	"time"
)

const (
	DateTime = "2006-01-02 15:04"
)

func main() {
	// 获取当前时间
	now := time.Now()
	fmt.Println(now)

	// 获取当前时间加1小时之后的时间
	add := now.Add(time.Hour)
	fmt.Println(add)

	// 计算两个时间间隔的差值
	hours := add.Sub(now).Hours()
	fmt.Println(hours)  // 1

	// 判断时间大小
	fmt.Println(now.After(add))  // false

	// 格式化时间:YYYY-MM-DD HH:mm:ss
	fmt.Println(now.Format(time.DateTime))
	fmt.Println(now.Format(DateTime))

	// 获取指定时区时间
	location, _ := time.LoadLocation("America/New_York")
	nyTime := time.Now().In(location)
	fmt.Println(nyTime.Format(time.DateTime))

	// 解析时间
	dtime := "2000-01-01 12:12:13"
	t, _ := time.Parse(time.DateTime, dtime)
	fmt.Println(t.Format(time.DateTime))

	// 计算时间间隔
	start := time.Date(2020, 1, 1, 0, 0, 0, 0, time.Local)
	end := time.Date(2020, 2, 1, 0, 0, 0, 0, time.Local)
	days := end.Sub(start).Hours() / 24
	fmt.Println(days)  // 31
}
```

## sync

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	// 并发安全的map
	m1 := sync.Map{}
	// store 存储
	m1.Store("name", "Tom")
	m1.Store("age", 20)

	// load 读取
	value, ok := m1.Load("name")
	if ok {
		fmt.Println(len(value.(string))) // 动态类型断言
	}
}
```

### sync.Mutex

```go
import "sync"

var mutex sync.Mutex
var rwMutex sync.RWMutex // 尽量使用读写锁

func Mutex() {
	mutex.Lock()
	defer mutex.Unlock()
	// 你的代码
}

func RWMutex() {
	// 加读锁
	rwMutex.RLock()
	defer rwMutex.RUnlock()
}
```

### sync.Once

```go
package main

import (
	"fmt"
	"sync"
)

var once sync.Once

// 这个方法不论调用几次，只会执行一次
func PrintOnce() {
	once.Do(func() {
		fmt.Println("----------")
	})
}

func main() {
	PrintOnce()
	PrintOnce()
	PrintOnce()
}
```

### sync.WaitGroup

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	res := 0
	wg := sync.WaitGroup{}
	wg.Add(10)
	for i := 0; i < 10; i++ {
		go func(value int) {
			res += value
			wg.Done()
		}(i)
	}

	//wg.Wait() // 45
	fmt.Println(res) // 10
}
```
